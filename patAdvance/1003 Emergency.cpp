#include<iostream>
#include<string>
#include<cstring>//memset这个函数要用到
using namespace std;

/*
题目：
作为一个城市紧急援救队的指挥者，你得到了一个国家的特殊地图。
地图上分散着几座城市，城市间用道路连接着。每个城市援救队的数量以及两座城市之间每条道路的长度已经在地图上标出。
当某些城市发生了突发事件，需要你的帮助时，
你的工作是带领你的队伍尽快的赶到事发现场，与此同时，召集尽可能多的在路上的队伍。
输入：
每个输入文件包含一个测试实例。每个实例的第一行有四个正整数：
N(<= 500)是城市的个数（城市的编号从0到N-1），
M是道路的个数，
C1和C2分别是你现在所在的城市以及你必须去救援的城市。
下一行有N个整数，第i个整数是第i个城市中救援队的数量。
然后下面有M行，每行表示一条道路。每一行有三个整数c1,c2和L，分别表示道路连接的两个城市以及道路的长度。保证C1到C2之间存在至少一条路径。
输出：
对于每个测试实例，在一行中输出两个数字：C1和C2之间不同的最短路径的个数，你能聚集起来的最多的救援队数量。
一行中的所有数字必须被一个空格分隔开，在每行的结尾不允许出现空格。
样例输入
5 6 0 2                       意思是5个城市，6条道路，从城市0，去城市2
1 2 1 5 3					  意思是0城市权重为1,1城市权重2,2城市权重1,3城市权重5,4城市权重3
0 1 1						  道路：链接0,1，道路长1
0 2 2						  道路：链接0,2，道路长2
0 3 1						  道路：链接0,3，道路长1
1 2 1						  道路：链接1,2，道路长1
2 4 1						  道路：链接2,4，道路长1
3 4 1						  道路：链接3,4，道路长1
样例输出
2 4							  城市0和城市2的最短路径有2种，最多的救援队输了为4（0->1->2）
*/

#define INF 0x7FFFFF
int u[502] = { 0 };//用来存访问状态 1-访问 0-未访问
int teams[502] = { 0 };//顶点的权重
int mp[502][502];//描述图的二维数组
int n, m, st, en;//顶点数，边数，开始节点，结束节点
int shortNum = 0, maxteam = 0, mindist = INF;//最小路径个数，最多的顶点权重数，最短距离

/*
难点：
1：dfs本身我个人觉得递归起来不太好理解
2：加入的一些判断，容易搞混，AC不了

*/
void dfs(int s, int dis, int team) {//到达S结点时的距离，teams
	//如果开始节点 = 结束节点，这里是程序的出口了，表明到了终点了
	if (s == en) {
		//如果dis 比最短距离还要小
		//这个mindist一开始肯定是INF，第一次到终点被设置为dis，退栈找其他路径时候，就可以和原来dis进行对比了
		if (dis<mindist) {
			//那么最短距离就是dist
			mindist = dis;
			//最短路径个数为1
			shortNum = 1;
			//顶点最大权值为
			maxteam = team;
		}
		//相等，就意味着多了一个最短路径了
		else if (dis == mindist) {
			shortNum++;
			//取一个最大的team值就可以了
			if (team>maxteam) maxteam = team;
		}
		return;
	}
	//这个是用来表明s这个节点已经被访问过了
	u[s] = 1;
	//对所有的N个节点执行深度优先搜搜
	for (int i = 0; i<n; i++) {
		//如果i节点没有被访问，并且到下一个节点有路径
		if (u[i] == 0 && mp[s][i]>0) {
			//递归遍历，mp[s][i]
			dfs(i, dis + mp[s][i], team + teams[i]);
		}
	}
	u[s] = 0;
}

int main() {
	int i;
	//把n，m，c1,c2读进来
	scanf_s("%d%d%d%d", &n, &m, &st, &en);
	//把n个城市各自的救援队伍存起来
	for (i = 0; i<n; i++) scanf_s("%d", &teams[i]);
	//把mp这个二维数组所有的位置都赋值为-1,即没有边的都为-1
	memset(mp, -1, sizeof(mp));
	for (i = 0; i<m; i++) {
		int t1, t2, dis;
		scanf_s("%d%d%d", &t1, &t2, &dis);
		//把每个顶点（城市）之间对应的路的距离存到二维数组mp中去
		mp[t1][t2] = mp[t2][t1] = dis;
	}
	//深度优先遍历，参数为开始节点st，
	dfs(st, 0, teams[st]);

	printf("%d %d\n", shortNum, maxteam);
	return 0;

}