/**

07-图4 哈利・波特的考试（25 分）
哈利・波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。

现在哈利・波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利・波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利・波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。

输入格式:

输入说明：输入第1行给出两个正整数N (≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。

输出格式:

输出哈利・波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。

输入样例:

6 11
3 4 70
1 2 1
5 4 50
2 6 50
5 6 60
1 3 70
4 6 60
3 6 80
5 1 100
2 4 60
5 2 80
输出样例:

4 70
**/


#include<iostream> 
#define MaxSize 100 //最多顶点数 
#define INF 65535  //int的最大值 
using namespace std;  
 
struct MGraph{  
    int n;  
    int m;  
    int s[MaxSize][MaxSize];  
};
MGraph g;


void FindAnimal(){
	//Floyd算法，三重循环 建立任意两点的最短距离矩阵 
	for(int k=0;k<g.n;k++){ 
		for(int i=0;i<g.n;i++){
			for(int j=0;j<g.n;j++){
				//(i!=k)&&(j!=i)为何不分别为循环i和j的条件 ==>不能，若作为for循环条件，一旦不满足，就终止循环了，后面符合条件的也不执行了
				//放在if里，符合就执行，不符合就跳过执行下个 
				if((i!=k)&&(j!=i)&&(g.s[i][k]+g.s[k][j] < g.s[i][j])){
					g.s[i][j] = g.s[i][k] + g.s[k][j];					
				}							
			}
		}
	}
	
	/*for(int i=0;i<g.n;i++){
		for(int j=0;j<g.n;j++){
			cout<<g.s[i][j]<<" ";
		}
		cout<<endl;
	}*/
	
	int animal;
	//从最长距离中找最端距离 
	int MinDist=INF;
	for(int i=0;i<g.n;i++){
		//找最长距离 
		int MaxDist=0; 
		for(int j=0;j<g.n;j++){
			if((i!=j) && (g.s[i][j]>MaxDist)){ //i!=j去掉主对角线元，因为主对角线元肯定是INF
				MaxDist=g.s[i][j]; 	
				//cout<<"("<<i<<","<<j<<")="<<g.s[i][j]<<" ";			
			}
		}

		if(MaxDist==INF){//不是一整个连通集，而是多个分的连通集，即：有i无法变出的动物 
			cout<<"0"<<endl;
			return;//直接退出 
		}
		if(MaxDist < MinDist){
			MinDist=MaxDist;
			animal=i+1;//i+1是因为动物下边从1开始 
		} 
	}
	cout<<animal<<" "<<MinDist<<endl;
}

  
int main()  
{  
	//freopen("input.txt","r",stdin);
	int n,m,i,j,v1,v2,weight; 
	cin>>n>>m;
	g.n=n;
	g.m=m;
	//1初始化邻接矩阵 
	for(i=0;i<g.n;i++){ 
		for(j=0;j<g.n;j++){
			g.s[i][j]=INF;
		}
	}	
	//2插入边
		while(g.m--){
			cin>>v1>>v2>>weight;
			 --v1;--v2;//动物从1开始，图从0开始
			g.s[v1][v2]=weight;	
			g.s[v2][v1]=weight;		
		}

	
	//3.找最长距离中的最短距离对应的点及这个最短距离
	FindAnimal(); 
	
	return 0;
} 
